{"meta":{"title":"大渔小予","subtitle":"","description":"大渔小予","author":"muxq","url":"http://localhost:4000","root":"/"},"pages":[{"title":"categories","date":"2022-07-29T08:48:46.000Z","updated":"2022-07-29T08:49:15.740Z","comments":true,"path":"categories/index.html","permalink":"http://localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-07-29T08:52:25.000Z","updated":"2022-07-29T08:52:35.877Z","comments":true,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-29T08:47:49.000Z","updated":"2022-07-29T08:48:11.278Z","comments":true,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows反调试技术","slug":"antidebug01","date":"2022-07-29T09:36:47.000Z","updated":"2022-08-02T09:38:24.160Z","comments":true,"path":"2022/07/29/antidebug01/","link":"","permalink":"http://localhost:4000/2022/07/29/antidebug01/","excerpt":"前言首先感谢 github 和 hexo，让自己能够白 piao 一把，轻松搭建一个属于自己的博客，能够有一个记录，分享和学习的平台，开源，是这个世界最伟大的发明！ 开启本篇博文的正题，该篇博文主要讲解博主从接触到使用反调试工具的一些经验，如果你已是逆向大神，请指正文中的不正确的之处，博主在这里不胜感激，我也是逆向界的小学生，希望通过博客结识对逆向感兴趣的朋友共同学习和突破。在没有接触反调试工具前，一直认 PE 程序逆向是一件非常困难的事情，相信很多 Windows 程序员都存在这样的观点。碰巧在工作中也遇到过需要实现保护自己程序的需求，这时候懵懂的了解了代码混淆，程序加壳的概念，但是当时并不的这些手段对 Windows 程序员开发的程序有多大作用，直到最近，工作中需要对竞品分析，分析同行产品中某一功能的实现原理，才对逆向有了一定的认知，随着不断的了解，发现原来自己写的程序都在”裸奔”。 本篇将结合实际用例来说明如何实现静态和动态逆向分析。","text":"前言首先感谢 github 和 hexo，让自己能够白 piao 一把，轻松搭建一个属于自己的博客，能够有一个记录，分享和学习的平台，开源，是这个世界最伟大的发明！ 开启本篇博文的正题，该篇博文主要讲解博主从接触到使用反调试工具的一些经验，如果你已是逆向大神，请指正文中的不正确的之处，博主在这里不胜感激，我也是逆向界的小学生，希望通过博客结识对逆向感兴趣的朋友共同学习和突破。在没有接触反调试工具前，一直认 PE 程序逆向是一件非常困难的事情，相信很多 Windows 程序员都存在这样的观点。碰巧在工作中也遇到过需要实现保护自己程序的需求，这时候懵懂的了解了代码混淆，程序加壳的概念，但是当时并不的这些手段对 Windows 程序员开发的程序有多大作用，直到最近，工作中需要对竞品分析，分析同行产品中某一功能的实现原理，才对逆向有了一定的认知，随着不断的了解，发现原来自己写的程序都在”裸奔”。 本篇将结合实际用例来说明如何实现静态和动态逆向分析。 理论知识 本篇所述均基于 Windowns 操作系统（这里先映下题 👈） 概念 Windows PE(Preinstallation Environment - 预安装环境)可执行程序 Windows 应用程序开发，是面向 Windows API 开发，运行在操作系统之上（这点很重要，也是我们能够逆向的基础） 逆向分为静态和动态，动态分析和静态分析都逆向的一种手段，两者相辅相成，在静态无法分析出实现过程时，可结合动态分析，反之亦然。 技术 懂一些汇编知识 有一定的 Windows 编程基础(开发语言无关) 能够熟练搜索 Windows API 帮助文档(这个很重要) 熟练的运用逆向工具 反调试工具 静态 IDA Pro &#x2F;&#x2F;推荐使用, free 版本只支持 x64 ghidra &#x2F;&#x2F;开源逆向工具媲美 IDA 动态 OllyDbg &#x2F;&#x2F;很久未维护，只支持 x86 x64Dbg &#x2F;&#x2F;推荐使用，支持 x86 和 x64 api-monitor &#x2F;&#x2F;api 监控程序，便于分析程序行为，和寻找逆向关键点 反调试的原理，基于 PE 文件的结构原理，和应用程序对系统 API 的依赖，通过分析应用程序所使用到的系统 API 和依赖的资源文件来逆向出应用程序所实现的功能。Windows 程序都是面向接口的编程，也就是可以将 Windows 操作系统比喻为一辆汽车，将我们的应用程序比喻为油门，脚刹和方向盘，你要去哪里和怎么走就是 Windows 程序员编程(面向 API)所实现的功能。 我们在逆向别人程序时，不强制要求使用哪个工具，一切以目的为导向，能够成功逆向出应用程序的实现都是好工具(🙋) ，同时你也可写一些逆向工具的插件。在逆向的世界里，IDA 与 OD 被形象的比喻为倚天剑和屠龙刀，得此二者基本可以号令天下了 😅 静态分析静态分析 是指使用逆向工具来分析应用程序的某个模块，对，就是字面的意思，那为什么需要静态分析呢？主要有以下几点： 1.应用程序只能部分拷贝 2.运行环境依赖，实际运行有依赖，如果用户的口令认证等 3.应用程序太大，实际分析的功能仅在一个 dll 模块内 我们用 C++来实现一个简单的动态链接库模块static_anti_dll_01.dll，源码如下： 12345678910111213141516171819202122232425262728#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;static const char *g_defult_msg = &quot;guest&quot;;extern &quot;C&quot; __declspec(dllexport) void say_hello(const char *msg) &#123; if (msg) &#123; fprintf(stdout, &quot;hello %s\\n&quot;, msg); &#125; else &#123; fprintf(stdout, &quot;hello %s\\n&quot;, g_defult_msg); &#125;&#125;extern &quot;C&quot; __declspec(dllexport) bool GetSystemVersion(int &amp;major, int &amp;minor) &#123; OSVERSIONINFO osvi; BOOL bIsWindowsXPorLater; ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFO)); osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); if (!GetVersionEx(&amp;osvi)) &#123; fprintf(stderr, &quot;get system version failed\\n&quot;); return false; &#125; major = osvi.dwMajorVersion; minor = osvi.dwMinorVersion; return true;&#125; 上面的代码相信大家能够看懂，say_hello函数用来接收一个字符串，并且打印到标准输出，GetSystemVersion用来获取当前的操作系统版本号。接下来我们就开始对它进行静态逆向分析 1.首先使用 IDA 加载这个 dll默认其他选项，点击 [OK] 2.IDA Pro 会静态的解析该 DLL 汇编和资源等信息默认第一个出现在逆向窗口的函数是入口函数，详细如上图 03.此实我们在入口函数按 F5 按键，IDA 会自动的帮助我们分析汇编代码，形成对应的伪代码从上图可知，这时的代码基本上能够看懂了，之所以说 IDA 比较伟大，是因为它为我们生成的 伪代码可读性较高 ，同理你可以使用其他的静态逆向工具来分析对比下。 04.一般的要分析 DLL 提供了哪些功能，首先查看这个 DLL 的导出函数表导出函数是我们分析这个 dll 的直观入口，因为 dll 通过导出接口来提供服务，所以通过提供的函数名称基本可推断出这个 dll 提供了哪些功能，从上图我们可以看到，当前被分析的 dll 提供了 3 个接口（DllEntryPoint、say_hello 和 GetSystemVersion），如果你要分析 dll 在被加载时做了哪些初始化，你可以通过 DllEntryPoint 入口函数来分析，因为这个入口函数在DllMain前被执行，所以一些全局变量的值，可以在这个函数中进行分析，同时这个函数也是找DllMain的入口，或者你可以在 函数窗口 中去搜索DllMain。 05. 静态逆向分析导出接口实现 1.对函数say_hello进行分析我们在导出接口，鼠标左键双击该函数，IDA 会自动的生成，关于该函数的汇编代码调用图标，此时按F5IDA会为我们生成基于当前函数的伪代码，如下图所示：至此 IDA 已经为我们做了很多，剩下逆向交给我们，对伪代码做如下解析： 1&gt; 从hello %s\\n字符串，我们可以推断出v3很可能是char * 2&gt; 进一步解析，如果 a1 不为空赋值给 v3 指针，如果为空指向一个全局地址，暂且先不管这个全局地址是什么 3&gt; 第 10 行通过_acrt_iob_func得到文件指针，经查这个函数用来获取标准输出指针 4&gt; 第 11 行，将标准输出和 v3 变量作为参数，调用sub_100010B0，查看此函数实现，会发现该函数调用_stdio_common_vfprintf进行格式化输出，所以我们这里基本得出该函数是用于标准化输出 5&gt; 我们再回过头去分析下全局变量unk_10003000， 双击后全局变量，跳转到汇编窗口unk_10003000 db 0B0h ; OFF32 SEGDEF [_rdata,100020B0]，该地址存储的是_rdata表的100020B0地址处, 跳转到该地址查看内存信息。经过我们分析后的函数实现如下： 2.同理对函数GetSystemVersion分析后如下所示: 从上面给出的两个函数的静态分析，你是否还觉得自己写的程序足够安全？ 动态分析动态分析 是指通过使用反调试程序启动应用程序，或者附加到应用程序，通过调试和查看应用程序内存的变化来达到逆向分析的手段应用程序可能存在动态得计算，比如： 客户端的某个功能需要服务端的输入作为参数，或者双方都需要通过一定的计算才能验证通过，这个时候的静态分析可能无法逆向出原理，需要动态逆向的协助，这也是为什么说动态和静态分析都重要，只要能够达到目的即可。发现通过 IDA 的菜单，可以看到有Debugger菜单，IDA 也提供了动态调试，但是相较于专用的动态逆向工具来说，功能还是不够全面，所以这里建议动态分析时，使用推荐的工具这里我们使用x64Dbg工具对应用程序进行分析。动态调试比较讲究技巧，同时也需要有一定的汇编基础，因为它不像 IDA会为你生成伪代码，动态逆向时，你只能看到伪代码，所以比较适合有针对性的破解。❗ 一般情况下一个应用程序，在不同的操作系统中，被加载到内存后的 VA 地址不会变化，因为每个进程都拥有相同大小的地址空间，应用程序启动的基地址每次也都相同，所以应用程序中的虚拟地址不会发生变化我们将通过一个实际的用例来演示，如何使用x64dbg，程序的源码。 动态逆向登录小程序登录小程序的实现逻辑如下： 通过动态分析这个简单的小程序，可以让大家了解如何去逆向它，逆向步骤如下： 1.在逆向前，首先介绍下x64dbg经常使用的快捷键，部分同OD快捷键 - F3: 程序载入快捷键 - F4: 运行程序到光标处 - F7: 单步步入(类似vs F11) - F8: 单步步过(类似vs F10) - F9: 运行程序(类似vs F5) - F12: 暂停程序 - Ctrl + F2 重新运行程序 - Alt + F9 运行到用户代码 🌟 2.打开x32dbg.exe，按F3载入dynamic_anti_01.exe程序 > 3.打开符号窗口，这里需要加载所依赖的Windows模块的符号文件，只有知道了应用程序使用了哪些API我们才能够逆向它的实现 > 4.寻找关键点，我们现在是不知道它是怎么验证，所以需要找到验证用户名口令的函数实现入口，如何找到呢？ A：单步执行是否可以？遇到太大的API调用就下断点，然后重新运行，步入阻塞的函数，如此循环？ Q: 通过尝试你会进入Windows的消息循环中，而且搞到精疲力尽，较难发现验证点，有没有更好的方法呢？ 注意: Alt + F9快捷键，我们可以先尝试错误的用户名口令，然后暂停程序运行，再按Alt + F9组合键让程序返回用户代码时，自动停止，然后再单步运行就可以找到验证的入口点了 我们随便输入一组错误的用户名和密码，这时候否按F12紧接着按Alt + F9登录小程序会继续运行，然后再点击 [确定] 按钮尝试登录，弹出错误选择框跳出来后点击确定，此时x64dbg会断点到用户区域，如下图所示： 5.从上图可分析出，该代码区域就是我们要找的入口点，可使用Ctrl + A让x64dbg为我们进一步解析此函数，我们可以把断点下到该函数入口处，Ctrl + F2重新运行该程序，输入一组错误数据，点击确定后会命中我门打的断点 > 6.单步调试时，主要关注`cmp`和`jmp, je, jne`指令，即可找到关键位置，同时你也可以修改对应的标志为，从而改变程序的运行逻辑，如下图所示: 以上为动态调试，你会发现输入了错误的用户名密码，也弹出了验证成功的提示！ 参考资料 PE文件结构详解 深入理解Windows线程 小甲鱼 OllyDbg 教程系列","categories":[{"name":"anti","slug":"anti","permalink":"http://localhost:4000/categories/anti/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://localhost:4000/tags/windows/"},{"name":"anti","slug":"anti","permalink":"http://localhost:4000/tags/anti/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-29T00:53:18.217Z","updated":"2022-08-01T05:39:59.078Z","comments":true,"path":"2022/07/29/hello-world/","link":"","permalink":"http://localhost:4000/2022/07/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"anti","slug":"anti","permalink":"http://localhost:4000/categories/anti/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://localhost:4000/tags/windows/"},{"name":"anti","slug":"anti","permalink":"http://localhost:4000/tags/anti/"}]}